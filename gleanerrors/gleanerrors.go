// Copyright 2022 Patrick Smith
// Use of this source code is subject to the MIT-style license in the LICENSE file.

// Package gleanerrors contains types used to report errors from parsers generated by glean.
//
// Although default error messages are provided, these will likely be unsatisfactory in practice.
// A program using a glean parser can likely produce better messages based on the context in
// which the parser is used.
package gleanerrors

import (
	"fmt"
	"strings"
)

// The tokens slice passed to a parse function had length 0.
type NoInput struct{}

// Default error message for NoInput.
func (_ NoInput) Error() string {
	return "no tokens in parser input"
}

// Location identifies a single token in the input passed to a parse function.
type Location struct {
	// The index of the token within the slice given to the parser.
	Index int

	// The token itself.
	Token interface{}
}

// MakeLocation returns the Location for a specific token.
//
// In edge cases, n might be -1 or len(tokens); if so, a nil token is used.
func MakeLocation(tokens []interface{}, n int) Location {
	if n < 0 || n >= len(tokens) {
		return Location{n, nil}
	}
	return Location{n, tokens[n]}
}

// A token did not match any rule expected at its position in the input.
//
// This is also returned when the parser input ends prematurely, without forming
// a valid match for the target symbol. In this case, Location.Index will be
// the length of the input, and Location.Token will be nil.
//
// Currently, the list of symbols valid at this point in the input is not returned.
// This may or may not be added in future.
type Unexpected struct {
	// The token found in the input.
	Location
}

// Default error message for Unexpected.
func (e Unexpected) Error() string {
	if e.Token == nil {
		return "unexpected end of input"
	}
	return fmt.Sprintf("unexpected token: %#v", e.Token)
}

// Rule represents a rule from the grammar being parsed.
type Rule struct {
	Name   string
	Target string
	Items  []string
}

// Range indicates the position of an error that may span multiple tokens.
//
// If the range is empty, Last.Index will be First.Index - 1; if this means
// Last.Index is -1, then Last.Token will be nil.
type Range struct {
	First, Last Location
}

// MakeRange creates a Range from a list of input tokens and the position of the range.
func MakeRange(tokens []interface{}, first, last int) Range {
	return Range{MakeLocation(tokens, first), MakeLocation(tokens, last)}
}

// There were multiple matches of a symbol to a range of input tokens.
//
// Only two matches are reported. It is possible for Rule1 and Rule2 to
// be identical, if a single rule can be applied in multiple ways.
type Ambiguous struct {
	// The range in which the ambiguity occurs.
	Range

	// Two of the rules that could be applied in valid parses. Possibly identical.
	//
	// These rules will have the same target symbol, and will apply to the
	// subsequence of tokens inside the parser input; this subsequence may
	// be larger than indicated in Range.
	Rule1, Rule2 Rule
}

// Default error message for Ambiguous.
func (e Ambiguous) Error() string {
	return fmt.Sprintf("ambiguous match for %s\n   %s: %s\nor %s: %s", e.Rule1.Target,
		e.Rule1.Name, strings.Join(e.Rule1.Items, " "),
		e.Rule2.Name, strings.Join(e.Rule2.Items, " "))
}
