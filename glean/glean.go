// Copyright 2021-2024 Patrick Smith
// Use of this source code is subject to the MIT-style license in the LICENSE file.

package main

import (
	"bytes"
	"errors"
	"flag"
	"fmt"
	"io/fs"
	"os"
	"strings"

	"github.com/pat42smith/glean"
	"github.com/pat42smith/glean/earley"
)

// Function usage prints a usage message to stderr.
func usage() {
	fmt.Fprint(os.Stderr, `
Usage: glean [options] [go files]

glean scans the Go files listed on the command line for functions implementing grammar
rules, and creates a Go source file containing a parser for the grammar. If no files are
listed, the package in the current directory is scanned.
See https://pkg.go.dev/github.com/pat42smith/glean/glean
for details on the rules and the accepted grammars. Options:

`)

	flag.PrintDefaults()
}

// die terminates the process with an error message.
func die(items ...interface{}) {
	fmt.Fprintln(os.Stderr, items...)
	os.Exit(1)
}

// marker is written as the first line of every generated Go file.
const marker = "// Code generated by glean. DO NOT EDIT.\n\n"

func main() {
	pHelp := flag.Bool("h", false, "print this help information")
	pOutFile := flag.String("o", "parse.go", "name of the Go file in which to write the parser")
	pPrefix := flag.String("p", "_glean_", "prefix for file scope names in the parser code")
	pPrint := flag.Bool("P", false, "print the grammar rules, do not generate a parser")
	pTarget := flag.String("t", "Target", "target symbol, the result of the parse")

	flag.CommandLine.Usage = usage
	flag.Parse()

	if *pHelp {
		usage()
		return
	}

	var pkg string
	getRules := func(g glean.RuleAdder) {
		args := flag.Args()
		var warnings []error
		var err error
		if len(args) == 0 {
			pkg, warnings, err = glean.ScanDir(g, ".")
		} else {
			pkg, warnings, err = glean.ScanFiles(g, args...)
		}
		if err != nil {
			die(err)
		}
		for _, w := range warnings {
			fmt.Fprintln(os.Stderr, w)
		}
	}

	if *pPrint {
		gp := make(grammarPrinter)
		getRules(gp)
		gp.Print()
		return
	}

	outFile := *pOutFile
	if info, e := os.Lstat(outFile); e == nil {
		if !info.Mode().IsRegular() {
			die("error:", outFile, "exists but is not a file.")
		}
		f, e := os.Open(outFile)
		if e != nil {
			die(e)
		}
		var buf [len(marker)]byte
		if n, e := f.Read(buf[:]); e != nil {
			die(e)
		} else if n != len(buf) || bytes.Compare(buf[:], []byte(marker)) != 0 {
			die("error:", outFile, "does not appear to have been produced by glean.")
		}
		if e := f.Close(); e != nil {
			die(e)
		}
	} else if !errors.Is(e, fs.ErrNotExist) {
		die(e)
	}

	var g glean.Grammar = new(earley.Grammar)
	getRules(g)

	parserText, err := g.WriteParser(glean.Symbol(*pTarget), pkg, *pPrefix)
	if err != nil {
		die(err)
	}
	parserText = marker + parserText

	if e := os.WriteFile(outFile, []byte(parserText), 0644); e != nil {
		die(e)
	}
}

// A grammarPrinter keeps a list of grammar rules and prints them.
//
// The rules for a target will be bunched together.
type grammarPrinter map[glean.Symbol]string

func (gp grammarPrinter) AddRule(name string, target glean.Symbol, items []glean.Symbol) error {
	var b strings.Builder
	b.WriteString(string(target))
	b.WriteString(" =")
	for _, i := range items {
		b.WriteString(" ")
		b.WriteString(string(i))
	}
	b.WriteString("\n")
	gp[target] += b.String()
	return nil
}

func (gp grammarPrinter) Print() {
	for _, s := range gp {
		fmt.Print(s)
	}
}
